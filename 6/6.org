* Feeding Ants
** The problem
DMOJ coci14c4p4
** Reading the Input
#+begin_src C
    #include <stdio.h>
    #include <stdlib.h>
    #include <string.h>

    #define MAX_NODES 1000

    typedef struct edge {
        int to_node, percentage, superpipe;
        struct edge *next;
    } edge;

  int main(void) {
      static edge *adj_list[MAX_NODES + 1] = {NULL};
      static int liquid_needed[MAX_NODES + 1];
      int num_nodes, i;
      int from_node, to_node, percentage, superpipe;
      edge *e;
      scanf("%d", &num_nodes);

      for (i = 0; i < num_nodes - 1; i++) {
          scanf("%d%d%d%d", &from_node, &to_node, &percentage, &superpipe);
          e = malloc(sizeof(edge));
          if (e == NULL) {
              fprintf(stderr, "malloc error\n");
              exit(1);
          }
          e->to_node = to_node;
          e->percentage = percentage;
          e->superpipe = superpipe;
          e->next = adj_list[from_node];
          adj_list[from_node] = e;
      }

      for (i = 1; i <= num_nodes; i++)
          scanf("%d", &liquid_needed[i]);
      solve(adj_list, liquid_needed);
      return 0;
  }
#+end_src

** Testing Feasibility
The function ~can_feed~ checks whether a certain amount of liquid is a
feasible solution:
#+begin_src C
  int can_feed(int node, double liquid,
               edge *adj_list[], int liquid_needed[]) {
      edge *e;
      int ok;
      double down_pipe;
      if (liquid_needed[node] != -1)
          return liquid >= liquid_needed[node];
      e = adj_list[node];
      ok = 1;
      while (e && ok) {
          down_pipe = liquid * e->percentage / 100;
          if (e->superpipe)
              down_pipe = down_pipe * down_pipe;
          if (!can_feed(e->to_node, down_pipe, adj_list, liquid_needed))
              ok = 0;
          e = e->next;
      }
      return ok;
  }
#+end_src

** Searching for a Solution
To look for a solution we will use binary search:
#+begin_src C
#define HIGHEST 2000000000
void solve(edge *adj_list[], int liquid_needed[]) {
    double low, high, mid;
    low = 0;
    high = HIGHEST;
    while (high - low > 0.00001) {
	mid = (low + high) / 2;
	if (can_feed(1, mid, adj_list, liquid_needed))
	    high = mid;
	else
	    low = mid;
    }
    printf("%.4lf\n", high);
}
#+end_src

* River Jump
** The Problem
[...]
** A Greedy Idea
What about ``find[ing] the two rocks that are closest together and
remove the one that's closest to its other neighbor rock, and
reapeat''?

Pretty intuitive, but it doesn't work...
** Testing Feasibility
Is it possible to achieve a minimum gap of at least /d/?

We can answer by following this rule: start from 0 and, in order,
remove each rock that is too close to the previous one. Remove the
rightmost one if it's too close to the end of the river. Does that
suffice?

#+begin_src C
  int can_make_min_distance(int distance, int rocks[], int num_rocks,
                            int num_remove, in length) {
      int i;
      int removed = 0, prev_rock_location = 0, cur_rock_location;
      if (length < distance)
          return 0;
      for (i = 0; i < num_rocks; i++) {
          cur_rock_location = rocks[i];
          if (cur_rock_location - prev_rock_location < distance)
              removed++;
          else
              prev_rock_location = cur_rock_location;
      }
      if (length - prev_rock_location < distance)
          removed++;
      return removed <= num_remove;
  }
#+end_src

How do we know this greedy algorithm is correct? [...]

Now that we know how to check /feasibility/, we can use binary search
to find /optimality/!

** Searching for a Solution
#+begin_src C
  void solve(int rocks[], int num_rocks,
             int num_remove, int length) {
      int low, high, mid;
      low = 0;
      high = length + 1;
      while (high - low > 1) {
          mid = (low + high) / 2;
          if (can_make_min_distance(mid, rocks, num_rocks, num_remove, length))
              low = mid;
          else
              high = mid;
      }
      printf("%d\n", low);
  }
#+end_src

** Reading the input
#+begin_src C
  #define MAX_ROCKS 50000

  int compare(const void *v1, const void *v2) {
      int num1 = *(const int *)v1;
      int num2 = *(const int *)v2;
      return num1 - num2;
  }

  int main(void) {
      static int rocks[MAX_ROCKS];
      int length, num_rocks, num_remove, i;
      scanf("%d%d%d", &length, &num_rocks, &num_remove);
      for (i = 0; i < num_rocks; i++)
          scanf("%d", &rocks[i]);
      qsort(rocks, num_rocks, sizeof(int), compare);
      solve(rocks, num_rocks, num_remove, length);
      return 0;
  }
#+end_src

* Living Quality
In order to check feasibility, in Feeding Ants, we have used a
recursive traversal of a tree and, in River Jump, we have used a
greedy algorithm. Now, to efficiently check feasibility we will use
dynamic programming.

This is DMOJ ioi10p3.

** Sorting Every Rectangle
#+begin_src C
#define MAX_ROWS 3001
#define MAX_COLS 3001

typedef int board[MAX_ROWS][MAX_COLS];
#+end_src

How to determine the median quality rank of a rectangle, if we are given
the top-left and the bottom-right coordinates?

We can: sort the quality ranks present in the rectangle from lowest to
highest, and then pick out the one in the middle.

Sorting gives us an algorith with O(n log n). (Better algorithm
exist. In particular, there a O(n) algorithm exists for finding the
median...)

#+begin_src C
  int median(int top_row, int left_col, int bottom_row, int right_col,
      board q) {
      static int cur_rectangle[MAX_ROWS * MAX_COLS];
      int i, j, num_cur_rectangle;
      num_cur_rectangle = 0;
      for (i = top_row; i <= bottom_row; i++)
          for (j = left_col; j <= right_col; j++) {
              cur_rectangle[num_cur_rectangle] = q[i][j];
              num_cur_rectangle++;
          }
      qsort(cur_rectangle, num_cur_rectangle, sizeof(int), compare);
      return cur_rectangle[num_cur_rectangle / 2];
  }
#+end_src

Now that we are able to calculate the median of a rectangle we can loop
through each candidate rectangle and return the smallest median.

#+begin_src C
  int rectangle (int r, int c, int h, int w, board q) {
      int top_row, left_col, bottom_row, right_col;
      int best = r * c + 1;
      int result;
      for (top_row = 0; top_row < r - h + 1; top_row++)
          for (left_col = 0; left_col < c - w + 1; left_col++) {
              bottom_row = top_row + h - 1;
              right_col = left_col + w - 1;
              result = median(top_row, left_col, bottom_row, right_col, q);
              if (result < best)
                  best = result;
          }
      return best;
  }
#+end_src

This works, but... it's too slow. There are at the least two things we
can improve. At the moment, we sort each rectangle. That can be
disposed by binary search. Moreover, we create the ~cur_rectangle~
array from scratch for each rectangle. That can be disposed by
dynamic-programming!

** Binary Search
Low and everything smaller than ~low~ are infeasible; ~high~ and
everything larger than ~high~ are feasible.

#+begin_src C
  int rectangle(int r, int c, int h, int w, board q) {
      int low, high, mid;
      low = 0;
      high = r * c + 1;
      while (high - low > 1) {
          mid = (low + high) / 2;
          if (can_make_quality(mid, r, c, h, w, q))
              high = mid;
          else
              low = mid;
      }
      return high;
  }
#+end_src

Now we need an implementation of ~can_make_quality~ to test feasibility.

** Testing Feasibility
There is no need to sort... For each rectangle, we can replace each
value of it by -1 if it's less than or equal to ~quality~ and by 1 if
it's greater than it. We add all up, and if we get 0 or less we know
that the rectangle has a median rank or ~quality~ or less.
#+begin_src C
  int can_make_quality(int quality, int r, int c, int h, int w, board q) {
      static int zero_one[MAX_ROWS][MAX_COLS];
      int i, j;
      int top_row, left_col, bottom_row, right_col;
      int total;

      for (i = 0; i < r; i++)
          for(j = 0; j < c; j++)
              if (q[i][j] <= quality)
                  q[i][j] = -1;
              else
                  q[i][j] = 1;
    
      for (top_row = 0; top_row < r - h + 1; top_row++)
          for (left_col = 0; left_col < c - w + 1; left_col++) {
              bottom_row = top_row + h - 1;
              right_col = left_col + w -1;
              total = 0;
              for (i = top_row; i <= bottom_row; i++)
                  for (j = left_col; j <= right_col; j++)
                      total = total + zero_one[i][j];
              if (total <= 0)
                  return 1;
          }
      return 0;
  }
#+end_src

That works; and we are not sorting anymore. But there are a bunch of
nested loops (four)!

** Testing Feasibility More Quickly
#+begin_src C
  int can_make_quality(int quality, int r, int c, int h, int w, board q) {
      static int zero_one[MAX_ROWS][MAX_COLS];
      static int sum[MAX_ROWS + 1][MAX_COLS + 1];
      int i, j;
      int top_row, left_col, bottom_row, right_col;
      int total;

    
      for (i = 0; i < r; i++)
          for(j = 0; j < c; j++)
              if (q[i][j] <= quality)
                  q[i][j] = -1;
              else
                  q[i][j] = 1;

      for (i = 0; i <= c; i++)
          sum[0][i] = 0;
      for (i = 0; i <= r; i++)
          sum[i][0] = 0;
      for (i = 1;i <= r; i++)
          for (j = 1; j <= c; j++)
              sum[i][j] = zero_one[i-1][j-1] + sum[i-1][j] +
                  sum[i][j-1] - sum[i-1][j-1];

      for (top_row = 1; top_row <= r - h + 1; top_row++)
          for (left_col = 1; left_col <= c - w + 1; left_col++) {
              bottom_row = top_row + h - 1;
              right_col = left_col + w - 1;
              total = sum[bottom_row][right_col] - sum[top_row-1][right_col] -
                  sum[bottom_row][left_col-1] + sum[top_row-1][left_col-1];
              if (total <= 0)
                  return 1;
          }
      return 0;
  }
#+end_src

This is an O(m^2 log m) alrorigthm. Enough to pass all the test cases.

* Cave Doors

DMOJ problem ioi13p4.

This is the only case in which we won't use binary search to find an
optimal solution...

We have to write this function:
#+begin_src C
  void explore(int n)
#+end_src
Where ~n~ is the number of doors (and switches).

~explore~ will have to call two function provided by the judge

#+begin_src C
int tryCombination(int switch_positions[])
#+end_src

#+begin_src C
void answer(int switch_positions[], int door_for_switch[])
#+end_src

** Solving a SubTask
We are going first to solve a subtask. In the first substak each
switch ~i~ is a associated with door number ~i~. We only need to
discover the correct position, up (0) or down (1), of each switch.
This is the code for that subtask:
#+begin_src C
  void exploreCave(int n) {
      int switch_positions[n], door_for_switch[n];
      int i, result;
      for (i = 0; i < n; i++) {
          switch_positions[i] = 0;
          door_for_switch[i] = i;
      }
    
      for (i = 0; i < n; i++) {
          result = tryCombination(switch_positions);
          if (result == i) // door i is closed
              switch_positions[i] = 1;
      }
      answer(switch_positions, door_for_switch);
  }
#+end_src

** Using a Linear Search
The solution above of subtask 1 focuses on door 0, opens it or closes
it if necessary, and never messes with its switch again.

Now, though, we don't know which switch controls the current
door. What can we do? 

We can close door foo and then search through the switches its
associated switch!

#+begin_src C
  void exploreCave(int n) {
      int switch_positions[n], door_for_switch[n];
      int i;
      for (i = 0; i < n; i++)
          door_for_switch[i] = -1; //indicate that the door for each
                                   //switch is unkown

      for (i = 0; i < n; i++)
          set_a_switch(i, switch_positions, door_for_switch, n);

      answer(switch_positions, door_for_switch);
  }
#+end_src

We are using the helper function ~set_a_switch~ to search through the
switches to determine wich is associated with a certain door:
#+begin_src C
    void set_a_switch(int door, int switch_positions[],
                    int door_for_switch[], int n) {
      int i, result;
      int found = 0;

      // loop through the switches
      for (i = 0; i < n; i++)
          // set to 0 those switches that are not associated with any
          // door
          if (door_for_switch[i] == -1)
              switch_positions[i] = 0;
    
      result = tryCombination(switch_positions);
      if (result != door) { // if door is open
          // let's close it
          for (i = 0; i < n; i++)
              if (door_for_switch[i] = -1)
                  switch_positions[i] = 1;
      }			      

      // now that the door is closed, let's check try each switch to
      // open it
      i = 0;
      while (!found) {
          if (door_for_switch[i] == -1)
              switch_positions[i] = 1 - switch_positions[i];
          result = tryCombination(switch_positions);
          if (result != door)
              found = 1;
          else
              i++;
      }
      door_for_switch[i] = door;
    }
#+end_src

With ~set_a_switch~ we are performing a linear search. This means that
a single door could take up to 5000 calls of ~tryCombination~. But we
are allowed to call ~tryCombination~ up to 70000 times and we could
have 5000 doors!
