* Knight Chase
** The Problem
[[./dmoj_ccc99s4.png]]

[[./sample_input_output.png]]
** Moving Optimally
If we had an algorithm to determine the minimum number of moves that
the knight can take from its starting point to some destiantion, then
we could determine the number of knight moves required to get to each
pawn location and, if the knight can get there at the same time as the
pawn, then the knight wins. The same strategy can be use with respect
to stalemates. How to design such an algorithm?

An helpful idea: the knight starting point is reachable in zero
moves. From there we can calculate the sqaures reachable with one
move. Given those squares we can discover the squares that are
reachable in two moves. And so on. This technique is called
/breadth-first-search/ (BFS).

*** Implementing BFS
To represent a position on the board:
#+begin_src C
  typedef struct position {
      int row, col;
  } position;
#+end_src

The board:
#+begin_src C
  #define MAX_ROWS 99
  #define MAX_COLS 99
  typedef int board[MAX_ROWS + 1][MAX_COLS + 1];
#+end_src

To hold the position we discover during the BFS
#+begin_src C
  typedef position positions[MAX_ROWS * MAX_COLS];
#+end_src

~find_distance~ will be our implementation of the BFS. It is a
function that takes the starting location of the knight (~knight_row~
and ~knight_col~), the desired destination (~dest_row~ and ~dest_col~)
and the number of rows and columns in the board (~num_rows~,
~num_cols~). It returns the minimum number of moves for the knight to
go from the starting location to the destination. If there is no way
to get to the destination it returns -1.

There are two key arrays that drive the BFS:
- ~cur_positions~: it holds the positions discovered from the current of
  round of BFS.
- ~new_positions~: it holds the positions discovered in the next round.

#+begin_src C
  int find_distance(int knight_row, int knight_col,
                    int dest_row, int dest_col,
                    int num_rows, int num_cols) {
      positions cur_positions, new_positions;
      int num_cur_positions, num_new_positions;
      int i, j, from_row, from_col;
      board min_moves;
      for (i = 1; i <= num_rows; i++)
          for (j = 1; j <= num_cols; j++)
              min_moves[i][j] = -1;
      min_moves[knight_row][knight_col] = 0;
      cur_positions[0] = (position){knight_row, knight_col};
      num_cur_positions = 1;

      // Loop to discover new positions.
      // Stop running when we discover zero positions.
      while (num_cur_positions > 0) {
          num_new_positions = 0;
          for (i = 0; i < num_cur_positions; i++) {
              from_row = cur_positions[i].row;
              from_col = cur_positions[i].col;
              if (from_row == dest_row && from_col == dest_col)
                  return min_moves[dest_row][dest_col];

              //for each position, (try to) add a position
              add_position(from_row, from_col, from_row + 1, from_col + 2,
                           num_rows, num_cols, new_positions,
                           &num_new_positions, min_moves);
              add_position(from_row, from_col, from_row + 1, from_col - 2,
                           num_rows, num_cols, new_positions,
                           &num_new_positions, min_moves);
              add_position(from_row, from_col, from_row - 1, from_col + 2,
                           num_rows, num_cols, new_positions,
                           &num_new_positions, min_moves);
              add_position(from_row, from_col, from_row - 1, from_col - 2,
                           num_rows, num_cols, new_positions,
                           &num_new_positions, min_moves);
              add_position(from_row, from_col, from_row + 2, from_col + 1,
                           num_rows, num_cols, new_positions,
                           &num_new_positions, min_moves);
              add_position(from_row, from_col, from_row + 2, from_col - 1,
                           num_rows, num_cols, new_positions,
                           &num_new_positions, min_moves);
              add_position(from_row, from_col, from_row - 2, from_col + 1,
                           num_rows, num_cols, new_positions,
                           &num_new_positions, min_moves);
              add_position(from_row, from_col, from_row - 2, from_col - 1,
                           num_rows, num_cols, new_positions,
                           &num_new_positions, min_moves);
          }

          num_cur_positions = num_new_positions;
          for (i = 0; i < num_cur_positions; i++)
              cur_positions[i] = new_positions[i];
      }
      return -1;
  }
#+end_src

Here is the ~add_position~ helper function:

#+begin_src C
  void add_position(int from_row, int from_col,
                    int to_row, int to_col,
                    int num_rows, int num_cols,
                    positions new_positions, int *num_new_positions,
                    board min_moves) {
      struct position new_position;
      if (to_row >= 1 && to_col >= 1 &&
          to_row <= num_rows && to_col <= num_cols &&
          min_moves[to_row][to_col] == -1) {
          min_moves[to_row][to_col] = 1 + min_moves[from_row][from_col];
          new_position = (position){to_row, to_col};
          new_positions[*num_new_positions] = new_position;
          (*num_new_positions)++;
      }
  }
#+end_src

** Best Knight Outcome
~solve~ takes the starting row and columns of the pawn, the starting
row and column of the knight, and the numbers of rows and columns in
the board. It prints one line of output corresponding to whether the
knight wins, stalemates, or loses.

#+begin_src C
  void solve(int pawn_row, int pawn_col,
             int knight_row, int knight_col,
             int num_rows, int num_cols) {
      int cur_pawn_row, num_moves, knight_takes;

      cur_pawn_row = pawn_row;
      num_moves = 0;
      while (cur_pawn_row < num_rows) {
          knight_takes = find_distance(knight_row, knight_col,
                                       cur_pawn_row, pawn_col,
                                       num_rows, num_cols);
          if (knight_takes == num_moves) {
              printf("Win in %d knight move(s).\n", num_moves);
              return;
          }
          cur_pawn_row++;
          num_moves++;
      }

      cur_pawn_row = pawn_row;
      num_moves = 0;
      while (cur_pawn_row < num_rows) {
          knight_takes = find_distance(knight_row, knight_col,
                                       cur_pawn_row + 1, pawn_col,
                                       num_rows, num_cols);
          if (knight_takes == num_moves) {
              printf("Stalemate in %d knight move(s).\n", num_moves);
              return;
          }
          cur_pawn_row++;
          num_moves++;
      }

      printf("Loss in %d knight move(s).\n", num_rows - pawn_row - 1);
  }
#+end_src

#+begin_src C
  int main(void) {
      int num_cases, i;
      int num_rows, num_cols, pawn_row, pawn_col, knight_row, knight_col;
      scanf("%d", &num_cases);
      for (i = 0; i < num_cases; i++) {
          scanf("%d%d", &num_rows, &num_cols);
          scanf("%d%d", &pawn_row, &pawn_col);
          scanf("%d%d", &knight_row, &knight_col);
          sovle(pawn_row, pawn_col, knight_row, knight_col,
                num_rows, num_cols);
      }
      return 0;
  }
#+end_src
We have a solution! However... it's incorrect.

Instead of
#+begin_src C
  if (knight_takes == num_moves) {
#+end_src
we need
#+begin_src C
  if (knight_takes >= 0 && num_moves >= knight_takes &&
      (num_moves - knight_takes) % 2 == 0)
#+end_src

** A Time Optimization
Remove the following bit from ~find_distance~!
#+begin_src C
  if (from_row == dest_row && from_col == dest_col)
      return min_moves[dest_row][dest_col];
#+end_src
* Rope Climb

[[./rope_climb.png]]

[[./rope_climb_input_output_sample.png]]


We closely follow what we did for Knight Chase. Here, at it was there,
we need to minimize the number of moves.

The number of possible moves, here, depends on the Bob's current position.

Any move that would cause Bob to land on itching powder will be
disallowed in our BFS code.

Given that /j/, the distance that Bob jumps up, is at most /h/, the
minimum target height, we shouldn't let Bob get to height 2 x /h/ or
higher.

** Implementing BFS
We'll keep the name `board'...
#+begin_src C
  #define SIZE 1000000

typedef int board[SIZE * 2];
typedef int positions[SIZE * 2];
#+end_src

We will make one call of BFS in order to calculate the minimum number
of moves to get from height zero to each valid position.

#+begin_src C
  void find_distance(int target_height, int jump_distance,
                     int itching[], board min_moves) {
      static positions cur_positions, new_positions;
      int num_cur_positions, num_new_positions;
      int i, j, from_height;
      for (i = 0; i < target_height * 2; i++)
          min_moves[i] = -1;
      min_moves[0] = 0; // meaning: you can reach position 0 with 0 moves
      cur_positions[0] = 0; // positions found in this ``round''
      num_cur_positions = 1; // num of positions found in this ``round''

      while (num_cur_positions > 0) { // while we discover new positions
          num_new_positions = 0;
          for (i = 0; i < num_cur_positions; i++) {
              from_height = cur_positions[i];

              //Bob has exactly one jump distance, so there's only one
              //jump move to consider
              add_position(from_height, from_height + jump_distance,
                           target_height * 2 - 1,
                           new_positions, &num_new_positions,
                           itching, min_moves);
              // To handle the falling down, we use a loop.
              for (j = 0; j < from_height; j++)
                  add_position(from_height, j,
                               target_height * 2 - 1,
                               new_positions, &num_new_positions,
                               itching, min_moves);
          }

          num_cur_positions = num_new_positions;
          for (i = 0; i < num_cur_positions; i++)
              cur_positions[i] = new_positions[i];
      }
  }
#+end_src

~target_heigth~: The minimum height that Bob must reach (/h/).

~jump_distance~: The distance that Bob can jump up (/j/).

~itching~: the parameter that indicates whether itching is present. If
itching[i] is 0, then there is no itching at height i; otherwise,
there is.

~min_moves~: the board in which we store the minimum number of moves
to get to each position.

Helper function:
#+begin_src C
  void add_position(int from_height, int to_height, int max_height,
                    positions new_positions, int *num_new_positions,
                    int itching[], board min_moves) {
      if (to_height <= max_height && itching[to_height] == 0 &&
          min_moves[to_height] == -1) {
          min_moves[to_height] = 1 + min_moves[from_height];
          new_positions[*num_new_positions] = to_height;
          (*num_new_positions)++;
      }
  }
#+end_src

** Finding the Best Height
Now that we have the minimum number of moves to get to each position,
we have to choose, among the candidate positions, the one that
minimizes the number of moves:

#+begin_src C
  void solve(int target_height, board min_moves) {
      int best = -1;
      int i;

      for (i = target_height; i < target_height * 2; i++)
          if (min_moves[i] != -1 && (best == -1 || min_moves[i] < best))
              best = min_moves[i];
      printf("%d\n", best);
  }
#+end_src

The only thing left is reading the input:
#+begin_src C
  int main(void) {
      int target_height, jump_distance, num_itching_sections;
      static int itching[SIZE * 2] = {0};
      static board min_moves;
      int i, j, itch_start, itch_end;
      scanf("%d%d%d", &target_height, &jump_distance, &num_itching_sections);
      for (i = 0; i < num_itching_sections; i++) {
          scanf("%d%d", &itch_start, &itch_end);
          for (j = itch_start; j <= itch_end; j++)
              itching[j] = 1;
      }
      find_distance(target_height, jump_distance, itching, min_moves);
      solve(target_height, min_moves);
      return 0;
  }
#+end_src

However, you should get a ``Time-Limit-Exceeded'' error with this code.

** Solution 2
When using BFS we need to keep a couple of things in check: the number
of times we call BFS and the number of edges in the graphs. We are
already calling our BFS once, so... we need to reduce the number of
edges in the graph.

You can see where the problem lies by looking at Figure 4-5:

[[./figure_4-5.png]]

Fall edges grow quadratically...

*** Changing the Moves
We can't change the rules of the game Bob plays, but we can model that
game using a different graph. We need a graph with less edges. Of
course, the BFS on the new graph must produce the same answer as a BFS
on the old graph.

To cut down the number of fall edges we could allow only fall edges of
one meter. For example, if we wanted to go from 5 to 1, then we would
have to make four falls of one meter each, instead of one fall of 4
meters.

However, we can't let each of these mini falls count as a
move. Falling of four meters should count as one move, not four
moves. How do we do that? We can add to our model a further rope, so
that we have rope 0 (the old one) and rope 1. If Bob wants to fall, he
can jump to rope 1, fall as much as he wants, and then go back to rope
0 (no more fall allowed directly on rope 0 and no jump up allowed on
rope 1). Any move on rope 0 counts as one move, as usual. But, moves
on rope 1 are free. Each occuers at a cost of 0 moves.

This way we have doubled the number of nodes but we have drastically
decreased the number of edges. For height /h/, we have about 4h
edges. Linear!

[[./figure_4-6.png]]

This an example of a *weighted graph*, where each edge is given a
weight or cost (here each edge either costs one move or zero moves).

*** Adding Positions
More technically, when Bob in on rope 0, we can say that Bob is in
/state/ 0 and, when he is on rope 1, he is in /state/ 1.

#+begin_src C
  typedef struct position {
      int height, state;
  } position;

  typedef int board[SIZE * 2][2];
  typedef position positions[SIZE * 4];
#+end_src

Rather than starting from the ~find_distances~ function, we are gonna
start from the ~add_position~ functionS. Instead of one ~add_position~
function, we are going to have four, one for each type of move.

#+begin_src C
    void add_position_up(int from_height, int to_height, int max_height,
                         positions pos, int *num_pos,
                         int itching[], board min_moves) {
        int distance = 1 + min_moves[from_height][0];
        if (to_height <= max_height && itching[to_height] == 0 &&
            (min_moves[to_height][0] == -1 ||
             min_moves[to_height][0] > distance)) {
            min_moves[to_height][0] = distance;
            pos[*num_pos] = (position){to_height, 0};
            (*num_pos)++;
        }
    }

  void add_position_down(int from_height, int to_height,
                         positions pos, int *num_pos,
                         board min_moves) {
          int distance = min_moves[from_height][1];
          if (to_height >= 0 &&
              (min_moves[to_height][1] == -1 ||
               min_moves[to_height][1] > distance)) {
              min_moves[to_height][1] = distance;
              pos[*num_pos] = (positions){to_height, 1};
              (*num_pos)++;
          }
  }

  void add_position_01(int from_height,
                       positions pos, int *num_pos,
                       board min_moves) {
      int distance = 1 + min_moves[from_height][0];
      if (min_moves[from_height][1] == -1 ||
          min_moves[from_height][1] > distance) {
          min_moves[from_height][1] = distance;
          pos[*num_pos] = (position){from_height, 1};
          (*num_pos)++;
      }
  }

  void add_position_10(int from_height,
                       positions pos, int *num_pos,
                       int itching[], board min_moves) {
      int distance = min_moves[from_height][1];
      if (itching[from_height] == 0 &&
          (min_moves[from_height][0] == -1 ||
           min_moves[from_height][0] > distance)) {
          min_moves[from_height][0] = distance;
          pos[*num_pos] = (position){from_height, 0};
          (*num_pos)++;
      }
  }
#+end_src

*** BFS
#+begin_src C
  void find_distances(int target_height, int jump_distance,
                      int itching[], board min_moves) {
      static positions cur_positions, new_positions;
      int num_cur_positions, num_new_positions;
      int i, j, from_height, from_state;
      for (i = 0; i < target_height * 2; i++)
          for (j = 0; j < 2; j++)
              min_moves[i][j] = -1;
      min_moves[0][0] = 0;
      cur_positions[0] = (position){0, 0};
      num_cur_positions = 1;
      while (num_cur_positions > 0) {
          num_new_positions = 0;
          for (i = 0; i < num_cur_positions; i++) {
              from_height = cur_positions[i].height;
              from_state = cur_positions[i].state;

              if (from_state == 0) {
                  add_position_up(from_height, from_height + jump_distance,
                                  target_height * 2 - 1,
                                  new_positions, &num_new_positions,
                                  itching, min_moves);
                  add_position_01(from_height, new_positions, &num_new_positions,
                                  min_moves);
              } else {
                  add_position_down(from_height, from_height - 1,
                                    cur_positions, &num_cur_positions, min_moves);
                  add_position_10(from_height,
                                  cur_positions, &num_cur_positions,
                                  itching, min_moves);
              }
          }
          num_cur_positions = num_new_positions;
          for (i = 0; i < num_cur_positions; i++)
              cur_positions[i] = new_positions[i];
      }
  }
#+end_src

Finally, replace `find_distance' with `find_distances' in the ~main~
function, and update the ~solve~ function:
#+begin_src C
  void solve(int target_height, board min_moves) {
      int best = -1;
      int i;
    
      for (i = target_height; i < target_height * 2; i++)
          if (min_moves[i][0] != -1 && (best == -1 || min_moves[i][0] < best))
              best = min_moves[i][0];
      printf("%d\n", best);
  }
#+end_src
* Book Translation
** 
[[./book_translation.png]]

[[./book_translation_sample.png]]

** Building the Graph
The goal is to minimize the number of translations, not to spend
less. (However, if there are multiple ways to achieve a minimum number
of translation, then we have to choose the cheapest one.) If we wanted
to find the cheapest cost, then we would have had to use more
powerfool tools (see Chapter 5).

Each language will be associated with a number. English will be 0.

To store the graph we will use an /adjacency list/: an array with one
index per node, where each index stores a linked list of the edges
involving that node. We use linked lists of edges, rather tahn arrays
of edges, because we don't know in advance the number of edges for a
given node.

#+begin_src C
  #define MAX_LANGS 101
  #define WORD_LENGTH 16

  typedef struct edge {
      int to_lang, cost;
      // there is no from_lang because we already know the from_lang
      // based on which index of the adjacency list the edge is in
      struct edge *next;
  } edge;

  typedef int board[MAX_LANGS];
  typedef int positions[MAX_LANGS];
#+end_src

#+begin_src C
  int main(void) {
      static edge *adj_list[MAX_LANGS] = {NULL};
      static char *lang_names[MAX_LANGS];
      int i, num_targets, num_translators, cost, from_index, to_index;
      char *from_lang, *to_lang;
      edge *e;
      static board min_costs;
      scanf("%d%d\n", &num_targets, &num_translators);
      lang_names[0] = "English";

      for (i = 1; i <= num_targets; i++)
          lang_names[i] = read_word(WORD_LENGTH);

      // For each translator line, create two edge structs (one that
      // represents the translation from lang1 to lang2 and one that
      // represents the translation from lang2 to lang1) and add them to
      // the right linked list in the adj_list
      for (i = 0; i < num_translators; i++) {
          from_lang = read_word(WORD_LENGTH);
          to_lang = read_word(WORD_LENGTH);
          scanf("%d\n", &cost);
          from_index = find_lang(lang_names, from_lang);
          to_index = find_lang(lang_names, to_lang);
          e = malloc(sizeof(edge));
          if (e == NULL) {
              fprintf(stderr, "malloc error\n");
              exit(1);
          }
          e->to_lang = to_index;
          e->cost = cost;
          e->next = adj_list[from_index];
          adj_list[from_index] = e;
          e = malloc(sizeof(edge));
          if (e == NULL) {
              fprintf(stderr, "malloc error\n");
              exit(1);
          }
          e->to_lang = from_index;
          e->cost = cost;
          e->next = adj_list[to_index];
          adj_list[to_index] = e;	
      }
      find_distances(adj_list, num_targets + 1, min_costs); // populate min_costs (``board'')
      solve(num_targets + 1, min_costs);
      return 0;
  }
#+end_src

Helper functions:
#+begin_src C
  /*based on https://stackoverflow.com/questions/16870485 */
  char *read_word(int size) {
      char *str;
      int ch;
      int len = 0;
      str = malloc(size);
      if (str == NULL) {
          fprintf(stderr, "malloc error\n");
          exit(1);
      }
      while ((ch = getchar()) != EOF && (ch != ' ') && (ch != '\n')) {
          str[len++] = ch;
          if (len == size) {
              size = size * 2;
              str = realloc(str, size);
              if (str == NULL) {
                  fprintf(stderr, "realloc error\n");
                  exit(1);
              }
          }
      }
      str[len] = '\0';
      return str;
  }

  int find_lang(char *langs[], char *lang) {
      int i = 0;
      while (strcmp(langs[i], lang) != 0)
          i++;
      return i;
  }
#+end_src

** The BFS
#+begin_src C
  void add_position(int from_lang, int to_lang,
                    positions new_positions, int *num_new_positions,
                    board min_moves) {
      if (min_moves[to_lang] == -1) {
          min_moves[to_lang] = 1 + min_moves[from_lang];
          new_positions[*num_new_positions] = to_lang;
          (*num_new_positions)++;
      }
  }
#+end_src

#+begin_src C
  void find_distances(edge *adj_list[], int num_langs, board min_costs) {
      static board min_moves;
      static positions cur_positions, new_positions;
      int num_cur_positions, num_new_positions;
      int i, from_lang, added_lang, best;
      edge *e;
      for (i = 0; i < num_langs; i++) {
          min_moves[i] = -1;
          min_costs[i] = -1;
      }
      min_moves[0] = 0;
      cur_positions[0] = 0;
      num_cur_positions = 1;
      while (num_cur_positions > 0) { // while we discover new positions
          num_new_positions = 0;
          for (i = 0; i < num_cur_positions; i++) {
              from_lang = cur_positions[i];
              e = adj_list[from_lang];
              while (e) {
                  add_position(from_lang, e->to_lang,
                               new_positions, &num_new_positions, min_moves);
                  e = e->next;
              }
          }

          for (i = 0; i < num_new_positions; i++) {
              added_lang = new_positions[i];
              e = adj_list[added_lang];
              best = -1;
              while (e) {
                  if (min_moves[e->to_lang] + 1 == min_moves[added_lang] &&
                      (best == -1 || e->cost < best))
                      best = e->cost;
                  e = e->next;
              }
              min_costs[added_lang] = best;
          }
          num_cur_positions = num_new_positions;
          for (i = 0; i < num_cur_positions; i++)
              cur_positions[i] = new_positions[i];
      }
  }
#+end_src

** Total Cost
#+begin_src C
  void solve(int num_langs, board min_costs) {
      int i, total = 0;
      for (i = 1; i < num_langs; i++)
          if (min_costs[i] == -1) {
              printf("Impossible\n");
              return;
          } else {
              total = total + min_costs[i];
          }
      printf("%d\n", total);
  }
#+end_src
