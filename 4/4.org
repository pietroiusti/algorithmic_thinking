* Knight Chase
** The Problem
[[./dmoj_ccc99s4.png]]

[[./sample_input_output.png]]
** Moving Optimally
If we had an algorithm to determine the minimum number of moves that
the knight can take from its starting point to some destiantion, then
we could determine the number of knight moves required to get to each
pawn location and, if the knight can get there at the same time as the
pawn, then the knight wins. The same strategy can be use with respect
to stalemates. How to design such an algorithm?

An helpful idea: the knight starting point is reachable in zero
moves. From there we can calculate the sqaures reachable with one
move. Given those squares we can discover the squares that are
reachable in two moves. And so on. This technique is called
/breadth-first-search/ (BFS).

*** Implementing BFS
To represent a position on the board:
#+begin_src C
  typedef struct position {
      int row, col;
  } position;
#+end_src

The board:
#+begin_src C
  #define MAX_ROWS 99
  #define MAX_COLS 99
  typedef int board[MAX_ROWS + 1][MAX_COLS + 1];
#+end_src

To hold the position we discover during the BFS
#+begin_src C
  typedef position positions[MAX_ROWS * MAX_COLS];
#+end_src

~find_distance~ will be our implementation of the BFS. It is a
function that takes the starting location of the knight (~knight_row~
and ~knight_col~), the desired destination (~dest_row~ and ~dest_col~)
and the number of rows and columns in the board (~num_rows~,
~num_cols~). It returns the minimum number of moves for the knight to
go from the starting location to the destination. If there is no way
to get to the destination it returns -1.

There are two key arrays that drive the BFS:
- ~cur_positions~: it holds the positions discovered from the current of
  round of BFS.
- ~new_positions~: it holds the positions discovered in the next round.

#+begin_src C
  int find_distance(int knight_row, int knight_col,
                    int dest_row, int dest_col,
                    int num_rows, int num_cols) {
      positions cur_positions, new_positions;
      int num_cur_positions, num_new_positions;
      int i, j, from_row, from_col;
      board min_moves;
      for (i = 1; i <= num_rows; i++)
          for (j = 1; j <= num_cols; j++)
              min_moves[i][j] = -1;
      min_moves[knight_row][knight_col] = 0;
      cur_positions[0] = (position){knight_row, knight_col};
      num_cur_positions = 1;

      // Loop to discover new positions.
      // Stop running when we discover zero positions.
      while (num_cur_positions > 0) {
          num_new_positions = 0;
          for (i = 0; i < num_cur_positions; i++) {
              from_row = cur_positions[i].row;
              from_col = cur_positions[i].col;
              if (from_row == dest_row && from_col == dest_col)
                  return min_moves[dest_row][dest_col];

              //for each position, (try to) add a position
              add_position(from_row, from_col, from_row + 1, from_col + 2,
                           num_rows, num_cols, new_positions,
                           &num_new_positions, min_moves);
              add_position(from_row, from_col, from_row + 1, from_col - 2,
                           num_rows, num_cols, new_positions,
                           &num_new_positions, min_moves);
              add_position(from_row, from_col, from_row - 1, from_col + 2,
                           num_rows, num_cols, new_positions,
                           &num_new_positions, min_moves);
              add_position(from_row, from_col, from_row - 1, from_col - 2,
                           num_rows, num_cols, new_positions,
                           &num_new_positions, min_moves);
              add_position(from_row, from_col, from_row + 2, from_col + 1,
                           num_rows, num_cols, new_positions,
                           &num_new_positions, min_moves);
              add_position(from_row, from_col, from_row + 2, from_col - 1,
                           num_rows, num_cols, new_positions,
                           &num_new_positions, min_moves);
              add_position(from_row, from_col, from_row - 2, from_col + 1,
                           num_rows, num_cols, new_positions,
                           &num_new_positions, min_moves);
              add_position(from_row, from_col, from_row - 2, from_col - 1,
                           num_rows, num_cols, new_positions,
                           &num_new_positions, min_moves);
          }

          num_cur_positions = num_new_positions;
          for (i = 0; i < num_cur_positions; i++)
              cur_positions[i] = new_positions[i];
      }
      return -1;
  }
#+end_src

Here is the ~add_position~ helper function:

#+begin_src C
  void add_position(int from_row, int from_col,
                    int to_row, int to_col,
                    int num_rows, int num_cols,
                    positions new_positions, int *num_new_positions,
                    board min_moves) {
      struct position new_position;
      if (to_row >= 1 && to_col >= 1 &&
          to_row <= num_rows && to_col <= num_cols &&
          min_moves[to_row][to_col] == -1) {
          min_moves[to_row][to_col] = 1 + min_moves[from_row][from_col];
          new_position = (position){to_row, to_col};
          new_positions[*num_new_positions] = new_position;
          (*num_new_positions)++;
      }
  }
#+end_src

** Best Knight Outcome
~solve~ takes the starting row and columns of the pawn, the starting
row and column of the knight, and the numbers of rows and columns in
the board. It prints one line of output corresponding to whether the
knight wins, stalemates, or loses.

#+begin_src C
  void solve(int pawn_row, int pawn_col,
             int knight_row, int knight_col,
             int num_rows, int num_cols) {
      int cur_pawn_row, num_moves, knight_takes;

      cur_pawn_row = pawn_row;
      num_moves = 0;
      while (cur_pawn_row < num_rows) {
          knight_takes = find_distance(knight_row, knight_col,
                                       cur_pawn_row, pawn_col,
                                       num_rows, num_cols);
          if (knight_takes == num_moves) {
              printf("Win in %d knight move(s).\n", num_moves);
              return;
          }
          cur_pawn_row++;
          num_moves++;
      }

      cur_pawn_row = pawn_row;
      num_moves = 0;
      while (cur_pawn_row < num_rows) {
          knight_takes = find_distance(knight_row, knight_col,
                                       cur_pawn_row + 1, pawn_col,
                                       num_rows, num_cols);
          if (knight_takes == num_moves) {
              printf("Stalemate in %d knight move(s).\n", num_moves);
              return;
          }
          cur_pawn_row++;
          num_moves++;
      }

      printf("Loss in %d knight move(s).\n", num_rows - pawn_row - 1);
  }
#+end_src

#+begin_src C
  int main(void) {
      int num_cases, i;
      int num_rows, num_cols, pawn_row, pawn_col, knight_row, knight_col;
      scanf("%d", &num_cases);
      for (i = 0; i < num_cases; i++) {
          scanf("%d%d", &num_rows, &num_cols);
          scanf("%d%d", &pawn_row, &pawn_col);
          scanf("%d%d", &knight_row, &knight_col);
          sovle(pawn_row, pawn_col, knight_row, knight_col,
                num_rows, num_cols);
      }
      return 0;
  }
#+end_src
We have a solution! However... it's incorrect.

Instead of
#+begin_src C
  if (knight_takes == num_moves) {
#+end_src
we need
#+begin_src C
  if (knight_takes >= 0 && num_moves >= knight_takes &&
      (num_moves - knight_takes) % 2 == 0)
#+end_src

** A Time Optimization
Remove the following bit from ~find_distance~!
#+begin_src C
  if (from_row == dest_row && from_col == dest_col)
      return min_moves[dest_row][dest_col];
#+end_src
* Rope Climb

[[./rope_climb.png]]

[[./rope_climb_input_output_sample.png]]


We closely follow what we did for Knight Chase. Here, at it was there,
we need to minimize the number of moves.

The number of possible moves, here, depends on the Bob's current position.

Any move that would cause Bob to land on itching powder will be
disallowed in our BFS code.

Given that /j/, the distance that Bob jumps up, is at most /h/, the
minimum target height, we shouldn't let Bob get to height 2 x /h/ or
higher.

** Implementing BFS
We'll keep the name `board'...
#+begin_src C
  #define SIZE 1000000

typedef int board[SIZE * 2];
typedef int positions[SIZE * 2];
#+end_src

We will make one call of BFS in order to calculate the minimum number
of moves to get from height zero to each valid position.

#+begin_src C
  void find_distance(int target_height, int jump_distance,
                     int itching[], board min_moves) {
      static positions cur_positions, new_positions;
      int num_cur_positions, num_new_positions;
      int i, j, from_height;
      for (i = 0; i < target_height * 2; i++)
          min_moves[i] = -1;
      min_moves[0] = 0; // meaning: you can reach position 0 with 0 moves
      cur_positions[0] = 0; // positions found in this ``round''
      num_cur_positions = 1; // num of positions found in this ``round''

      while (num_cur_positions > 0) { // while we discover new positions
          num_new_positions = 0;
          for (i = 0; i < num_cur_positions; i++) {
              from_height = cur_positions[i];

              //Bob has exactly one jump distance, so there's only one
              //jump move to consider
              add_position(from_height, from_height + jump_distance,
                           target_height * 2 - 1,
                           new_positions, &num_new_positions,
                           itching, min_moves);
              // To handle the falling down, we use a loop.
              for (j = 0; j < from_height; j++)
                  add_position(from_height, j,
                               target_height * 2 - 1,
                               new_positions, &num_new_positions,
                               itching, min_moves);
          }

          num_cur_positions = num_new_positions;
          for (i = 0; i < num_cur_positions; i++)
              cur_positions[i] = new_positions[i];
      }
  }
#+end_src

~target_heigth~: The minimum height that Bob must reach (/h/).

~jump_distance~: The distance that Bob can jump up (/j/).

~itching~: the parameter that indicates whether itching is present. If
itching[i] is 0, then there is no itching at height i; otherwise,
there is.

~min_moves~: the board in which we store the minimum number of moves
to get to each position.

Helper function:
#+begin_src C
  void add_position(int from_height, int to_height, int max_height,
                    positions new_positions, int *num_new_positions,
                    int itching[], board min_moves) {
      if (to_height <= max_height && itching[to_height] == 0 &&
          min_moves[to_height] == -1) {
          min_moves[to_height] = 1 + min_moves[from_height];
          new_positions[*num_new_positions] = to_height;
          (*num_new_positions)++;
      }
  }
#+end_src
