* Knight Chase
** The Problem
[[./dmoj_ccc99s4.png]]

[[./sample_input_output.png]]
** Moving Optimally
If we had an algorithm to determine the minimum number of moves that
the knight can take from its starting point to some destiantion, then
we could determine the number of knight moves required to get to each
pawn location and, if the knight can get there at the same time as the
pawn, then the knight wins. The same strategy can be use with respect
to stalemates. How to design such an algorithm?

An helpful idea: the knight starting point is reachable in zero
moves. From there we can calculate the sqaures reachable with one
move. Given those squares we can discover the squares that are
reachable in two moves. And so on. This technique is called
/breadth-first-search/ (BFS).

*** Implementing BFS
To represent a position on the board:
#+begin_src C
  typedef struct position {
      int row, col;
  } position;
#+end_src

The board:
#+begin_src C
  #define MAX_ROWS 99
  #define MAX_COLS 99
  typedef int board[MAX_ROWS + 1][MAX_COLS + 1];
#+end_src

To hold the position we discover during the BFS
#+begin_src C
  typedef position positions[MAX_ROWS * MAX_COLS];
#+end_src

~find_distance~ will be our implementation of the BFS. It is a
function that takes the starting location of the knight (~knight_row~
and ~knight_col~), the desired destination (~dest_row~ and ~dest_col~)
and the number of rows and columns in the board (~num_rows~,
~num_cols~). It returns the minimum number of moves for the knight to
go from the starting location to the destination. If there is no way
to get to the destination it returns -1.

There are two key arrays that drive the BFS:
- ~cur_positions~: it holds the positions discovered from the current of
  round of BFS.
- ~new_positions~: it holds the positions discovered in the next round.

#+begin_src C
  int find_distance(int knight_row, int knight_col,
                    int dest_row, int dest_col,
                    int num_rows, int num_cols) {
      positions cur_positions, new_positions;
      int num_cur_positions, num_new_positions;
      int i, j, from_row, from_col;
      board min_moves;
      for (i = 1; i <= num_rows; i++)
          for (j = 1; j <= num_cols; j++)
              min_moves[i][j] = -1;
      min_moves[knight_row][knight_col] = 0;
      cur_positions[0] = (position){knight_row, knight_col};
      num_cur_positions = 1;

      // Loop to discover new positions.
      // Stop running when we discover zero positions.
      while (num_cur_positions > 0) {
          num_new_positions = 0;
          for (i = 0; i < num_cur_positions; i++) {
              from_row = cur_positions[i].row;
              from_col = cur_positions[i].col;
              if (from_row == dest_row && from_col == dest_col)
                  return min_moves[dest_row][dest_col];

              //for each position, (try to) add a position
              add_position(from_row, from_col, from_row + 1, from_col + 2,
                           num_rows, num_cols, new_positions,
                           &num_new_positions, min_moves);
              add_position(from_row, from_col, from_row + 1, from_col - 2,
                           num_rows, num_cols, new_positions,
                           &num_new_positions, min_moves);
              add_position(from_row, from_col, from_row - 1, from_col + 2,
                           num_rows, num_cols, new_positions,
                           &num_new_positions, min_moves);
              add_position(from_row, from_col, from_row - 1, from_col - 2,
                           num_rows, num_cols, new_positions,
                           &num_new_positions, min_moves);
              add_position(from_row, from_col, from_row + 2, from_col + 1,
                           num_rows, num_cols, new_positions,
                           &num_new_positions, min_moves);
              add_position(from_row, from_col, from_row + 2, from_col - 1,
                           num_rows, num_cols, new_positions,
                           &num_new_positions, min_moves);
              add_position(from_row, from_col, from_row - 2, from_col + 1,
                           num_rows, num_cols, new_positions,
                           &num_new_positions, min_moves);
              add_position(from_row, from_col, from_row - 2, from_col - 1,
                           num_rows, num_cols, new_positions,
                           &num_new_positions, min_moves);
          }

          num_cur_positions = num_new_positions;
          for (i = 0; i < num_cur_positions; i++)
              cur_positions[i] = new_positions[i];
      }
      return -1;
  }
#+end_src

Here is the ~add_position~ helper function:

#+begin_src C
  void add_position(int from_row, int from_col,
                    int to_row, int to_col,
                    int num_rows, int num_cols,
                    positions new_positions, int *num_new_positions,
                    board min_moves) {
      struct position new_position;
      if (to_row >= 1 && to_col >= 1 &&
          to_row <= num_rows && to_col <= num_cols &&
          min_moves[to_row][to_col] == -1) {
          min_moves[to_row][to_col] = 1 + min_moves[from_row][from_col];
          new_position = (position){to_row, to_col};
          new_positions[*num_new_positions] = new_position;
          (*num_new_positions)++;
      }
  }
#+end_src

** Best Knight Outcome
~solve~ takes the starting row and columns of the pawn, the starting
row and column of the knight, and the numbers of rows and columns in
the board. It prints one line of output corresponding to whether the
knight wins, stalemates, or loses.

#+begin_src C
  void solve(int pawn_row, int pawn_col,
             int knight_row, int knight_col,
             int num_rows, int num_cols) {
      int cur_pawn_row, num_moves, knight_takes;

      cur_pawn_row = pawn_row;
      num_moves = 0;
      while (cur_pawn_row < num_rows) {
          knight_takes = find_distance(knight_row, knight_col,
                                       cur_pawn_row, pawn_col,
                                       num_rows, num_cols);
          if (knight_takes == num_moves) {
              printf("Win in %d knight move(s).\n", num_moves);
              return;
          }
          cur_pawn_row++;
          num_moves++;
      }

      cur_pawn_row = pawn_row;
      num_moves = 0;
      while (cur_pawn_row < num_rows) {
          knight_takes = find_distance(knight_row, knight_col,
                                       cur_pawn_row + 1, pawn_col,
                                       num_rows, num_cols);
          if (knight_takes == num_moves) {
              printf("Stalemate in %d knight move(s).\n", num_moves);
              return;
          }
          cur_pawn_row++;
          num_moves++;
      }

      printf("Loss in %d knight move(s).\n", num_rows - pawn_row - 1);
  }
#+end_src

#+begin_src C
  int main(void) {
      int num_cases, i;
      int num_rows, num_cols, pawn_row, pawn_col, knight_row, knight_col;
      scanf("%d", &num_cases);
      for (i = 0; i < num_cases; i++) {
          scanf("%d%d", &num_rows, &num_cols);
          scanf("%d%d", &pawn_row, &pawn_col);
          scanf("%d%d", &knight_row, &knight_col);
          sovle(pawn_row, pawn_col, knight_row, knight_col,
                num_rows, num_cols);
      }
      return 0;
  }
#+end_src
We have a solution! However... it's incorrect.

Instead of
#+begin_src C
  if (knight_takes == num_moves) {
#+end_src
we need
#+begin_src C
  if (knight_takes >= 0 && num_moves >= knight_takes &&
      (num_moves - knight_takes) % 2 == 0)
#+end_src

** A Time Optimization
Remove the following bit from ~find_distance~!
#+begin_src C
  if (from_row == dest_row && from_col == dest_col)
      return min_moves[dest_row][dest_col];
#+end_src

