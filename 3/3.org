* Burger Fervor
** The problem
Homer has /t/ minutes and some burgers of two types. One type takes
/m/ minutes to eat and the other type takes /m/ minutes to eat. Homer
wants to spend all /t/ minutes eating burgers, but sometimes that's
not possible. If he can spend exactly /t/ minutes eating burgers, we
have to determine the max number of burgers he cant eat. If he can't
spend /t/ minutes eating burgers, we have to determin the max amount
of time he can spend eating burgers.

*** Input
#+begin_quote
We read test cases until there is no more input. Each test case is
represented by a line of three integers: /m/, the number of minutes it
takes to eat the first kind of burger; /n/, the number of minutes it
takes to eat the second kind of burger; and /t/, the number of minutes
that Homer will spend eating burgers and drinking beer. Each /m/, /n/,
and /t/ value is less than 10,000. (72)
#+end_quote

*** Output
#+begin_quote
For each test case:

- If Homer can spend exactly t minutes eating burgers, then output the
  maximum number of burgers that he can eat.

- Otherwise, output the maximum number of burgers that Homer can eat
  when maximizing his time eating burgers, a space, and the number of
  remaining minutes (during which he’ll drink beer).  The time limit
  for solving the test cases is three seconds. (72)
#+end_quote

** Optimal Solutions
We should determine whether Homer can eat burgers for exactly /t/
minutes. If he can, then we should report the max number of burgers he
can eat. If he can't, then we should check whether he can eat burgers
for exactly /t/-1 minutes. If he can, then we report the max number of
burgers he can eat and the number of minutes remaining (that he spend
drinking beers). If he can't...

If /t/ = 0, then the correct output is 0.

And what about other values for /t/?

Here is a strategy. Suppose Homer can spend exactly /t/ minutes eating
burgers.

The last burger he eats must be either a /m/ burger or a /n/
burger. If the last burger Homer eats in an optimal solution is a /m/
burgers, then we know that he has /t/ - /m/ minutes left to
spend. Those /t/ - /m/ minutes must be filled entirely with burgers
(remember our initial assumption). If we had the optimal number of
burgers to fill those /t/ - /m/ minutes, then we would be able to give
the solution: that number + one /m/-minute burger. If we knew that the
final burger that Homer eats in an optimal solution is a /n/-minute
burger, then we can say /mutatis mutandis/ the same.

But how can we know whether the last burger Homer eats? We don't need
to... We can just assume that it was a /m/-minute burger and solve the
problem that way. Then we assume that it was a /n/-minute burger and
solve the problem that way. In both case we have subproblems to
solve. This is a hint that we might want to use recursion.

** Recursion
We should begin by writing a function that solve the problem for /t/
minutes:
#+begin_src C
int solve_t(int m, int n, int t);
#+end_src

If Home can spend exactly /t/ minutes eating burgers, then we'll
return the maximum number of burgers he can eat. If Homer cannot spend
/t/ minutes eating only burgers, then we'll return -1.

We already know that:
#+begin_src C
  if (t == 0)
    return 0;
#+end_src

This is the /base/ of our recursion (Cf. chapter 2).

Consider that the final burger can be a /m/-minute burger only if /t/
>= /m/. (The same for the subproblem in which the minute are /t/ -
/m/: the final burger can be a /m/-minute burger only if /t/ - /m/ >=
m.) So we can say:
#+begin_src C
  int first;
  if (t >= m)
      first = solve_t(m, n, t - m);
  else
      first = -1;
#+end_src

The code, in the case of the /n/ minute burger, will be analogous:
#+begin_src C
  int first;
  if (t >= m)
      first = solve_t(m, n, t - m);
  else
      first = -1;
#+end_src

Zingaro summarizes the situation thus:
#+begin_quote
- The variable first is the solution to the t - m subproblem. If it’s
  -1, then we can’t fill t - m minutes with burgers. If it’s anything
  else, then it gives the optimal number of burgers that Homer can eat
  in exactly t - m minutes.

- The variable second is the solution to the t - n subproblem. If it’s
  -1, then we can’t fill t - n minutes with burgers. If it’s anything
  else, then it gives the optimal number of burgers that Homer can eat
  in exactly t - n minutes.
#+end_quote

It should be clear that:
#+begin_src C
  if (first == -1 && second == -1)
    return -1;
#+end_src

If /first/ or /second/ or both are greater than -1:
#+begin_src C
return max(first, second) + 1;
#+end_src

Here is the full function:
#+begin_src C
  int max(int v1, int v2) {
      if (v1 > v2)
          return v1;
      else
          return v2;
  }

  int solve_t(int m, int n, int t) {
      int first, second;
      if (t == 0)
          return 0;
      if (t >= m)
          first = solve_t(m, n, t - m);
      else
          first = -1;
      if (t >= n)
          second = solve_t(m, n, t - n);
      else
          second = -1;
      if (first == -1 && second == -1)
          return -1;
      else
          return max(first, second) +1 ;
#+end_src

That magically works...

Remember, though, that we also have to print the minute Home drinks
beer in cases where he can't spend all the time eating burgers.

#+begin_src C
  void solve(int m, int n, int t) {
      int result, i;
      result = solve_t(m, n, t);
      if (result >= 0)
          printf("%d\n", result);
      else {
          i = t - 1;
          result = solve_t(m, n, i);
          while (result == -1) {
              i--;
              result = solve_t(m, n, i);
          }
          printf("%d %d\n", result, t - 1);
      }
  }
#+end_src

Finally we write the main function:
#+begin_src C
  int main(void) {
      int m, n, t;
      while (scanf("%d%d%d", &m, &n, &t) != -1)
          solve(m, n, t);
      return 0;
  }
#+end_src

** Memoization
Our previous solution delivers the correct result but it's too
slow. Why?

The values of /t/ can be up to 9,999, but with the following input the
we already exceed the time-limit!
#+begin_src 
4 2 88
#+end_src

A way in which we could save some work is avoiding call solve_t with
value with which we have already called it.

Here is our previous solution with some code that counts the number of
times solve_t is called:
#+begin_src C
  unsigned long long total_calls;

  int solve_t(int m, int n, int t) {
      int first, second;
      total_calls++;
      if (t == 0)
          return 0;
      if (t >= m)
          first = solve_t(m, n, t - m);
      else
          first = -1;
      if (t >= n)
          second = solve_t(m, n, t - n);
      else
          second = -1;
      if (first == -1 && second == -1)
          return -1;
      else
          return max(first, second) + 1;
  }

  void solve(int m, int n, int t) {
      int result, i;
      total_calls = 0;
      result = solve_t(m, n, t);
      if (result >= 0)
          printf("%d\n", result);
      else {
          i = t - 1;
          result = solve_t(m, n, i);
          while (result == -1) {
              i--;
              result = solve_t(m, n, i);
          }
          printf("%d %d\n", result, t - i);
      }
      printf("Total calls to solve_t: %llu\n", total_calls);
  }
#+end_src

Now we should find a way to remember the answers to a the calls of
solve_t we make, so that we don't have to call solve_t again when we
need those answers. This technique is called /memoization/.

Memoization works in two steps:
1. Declare an array large enough to hold the solutions to all
   possible subproblems. This array is typicalle called ~memo~. It
   should be initialized to a valued reserved to mean ``unknown
   value''.
2. At the start of the recursive function, add code to check whether
   the subproblem solution has already been solved. If the answer is
   already in ~memo~, then we simply return it. Otherwise we have to
   solve the problem now. Whenever we solve a problem, we store the
   solution in ~memo~.

Let's implement this.

The right place where to declare and initialize the ~memo~ array is
~solve~, since that's the function that first gets called for each
test case. ``Unknown value'' will represented by -2.

#+begin_src C
  #define SIZE 10000

  void solve(int m, int n, int t) {
      int result, i;
      int memo[SIZE];
      for (i = 0; i <= t; i++)
          memo[i] = -2;
      result = solve_t(m, n, t, memo);
      if (result >= 0)
          printf("%d\n", result);
      else {
          i = t - 1;
          result = solve_t(m, n, i, memo);
          while (result == -1) {
              i--;
              result = solve(m, n, i, memo);
          }
          printf("%d %d\n", result, t - 1);
      }
  }
#+end_src

As you can see, now we are passing ~memo~ to ~solve_t~. Here is the
update version of ~solve_t~:

#+begin_src C
  int solve_t(int m, int n, int t, int mem[]) {
      int first, second;
      if (memo[t] != -2)
          return memo[t];
      if (t == 0) {
          memo[t] = 0;
          return memo[t];
      }
      if (t >= m)
          first = solve_t(m, n, t - m, memo);
      else
          first = -1;
      if (t >= n)
          second = solve_t(m, n, t - n, memo);
      else
          second = -1;
      if (first == -1 && second == -1) {
          memo[t]  = -1;
          return memo[t];
      } else {
          memo[t] = max(first, second) + 1;
          return memo[t];
      }
  }
#+end_src

** Dynamic Programming
Suppose we could orchestrate things so that ~memo~ always hold the
solution we look up. Never having to make a recursive call. Always
been able to look up the solution right away. /Dynamic Programming/
makes this possible.

Our dynamic-programming solution dispenses with the ~solve_t~
function and does everythin inside ~solve~.

#+begin_src C
  void solve(int m, int n, int t) {
      int result, i, first, second;
      int dp[SIZE];
      dp[0] = 0;
      for (i = 1; i <= t; i++) {
          if (i >= m)
              first = dp[i - m];
          else
              first = -1;
          if (i >= n)
              second = dp[i - n];
          else
              second = -1;
          if (first == -1 && second == -1)
              dp[i] = -1;
          else
              dp[i] = max(first, second) + 1;
      }

      result = dp[t];
      if (result >= 0)
          printf("%d\n", result);
      else {
          i = t - 1;
          result = dp[i];
          while (result == -1) {
              i--;
              result = dp[i];
          }
          printf("%d %d\n", result, t - i);
      }
  }
#+end_src

** The steps toward an optimal solution
The first step is to show how to decompose an optimal solution to a
problem into optimal solutions for smaller subproblems.

The second step is using recursion.

The possible problem with a recursive solution is that the same
subproblems sometimes are solved over and over (``overlapping
subproblems''). When there is such a problem, then memoization can be
used (third step). The subproblems still overlap, but they are solved
only once.

Sometimes we want eliminate recursion and we can do so by solving
smaller subproblems before larger subproblems. This is dynamic
programming (fourth step).

What's better: memoization or dynamic programming? It depends...


* Moneygrubbers
** The problem
You want to buy at least /k/ apples and do so a cheaply as possible.
You are given the price of one apple and /m/ pricing schemes. Each
pricing scheme gives you a number /n/ of apples and a price /p/ for
it.
** Input
#+begin_quote
We read test cases until there’s no more input. Each test case
consists of the following lines:

- A line containing the price for buying one apple, followed by the
  number /m/ of pricing schemes for this test case. /m/ is at most 20.

- /m/ lines, each of which gives a number /n/ and total price /p/ for
  buying /n/ apples. /n/ is between 1 and 100.

- A line containing integers, where each integer /k/ is between 0 and
  100 and gives the desired number of apples to buy.

Each price in the input is a floating-point number with exactly two
decimal digits. (92)
#+end_quote

For example:
#+begin_src
1.75 2
3 4.00
2 2.50
1 4
#+end_src
** Output
#+begin_quote
For each test case, output the following:
- A line containing `Case /c/' where /c/ is the number of the test
  case starting at 1.
  
- For each integer /k/, a line containing Buy /k/ for $/d/, where /d/
  is the cheapest way that we can buy at least /k/ apples. (92)
#+end_quote

For example:
#+begin_src
Case 1:
Buy 1 for $1.75
Buy 4 for $5.00
#+end_src

** Characterizing Optimal Solutions
In Burger Fervor we reasoned that if Homer can spend /t/ minutes
eating burgers, then his last burger must be either a /m/-minute
burger or a /n/-minute burger. We can say something analogus here.
An optimal solutions for buying /k/ apples must end in one of small
number of ways:
- using one of the /m/ pricing schemes;
- buying a single apple.
In Burger Fervor we had to solve two subproblems. Here we have to
solve /m/ + 1 subproblems.

An optimal solution for buying /k/ apples ends with us paying /p/
dollars for /n/ apples. This means that there are also /k/ - /n/
apples that we need to buy and their cost must be added to /p/. The
/k/ - /n/ apples moreover must be bought using an optimal solution. If
the solution to the subproblem weren't optimal, then the solution to
the problem wouldn't be optimal either!

Notice that --- unlike Burger Fervor --- here we can always find a
solution for any number /k/, given that we always have the option of
buying one apple.

** Recursion
Let's write a helper function:
#+begin_src C
  double solve_k(int num[], double price[], int num_schemes, double unit_price, int num_items);
#+end_src
~num~: An array of numbers of apples, one element per pricing scheme.

~price~: An array of prices, one element per pricing scheme.

~num_schemes~: The number of pricing schemes.

~unit_price~: The price for one apple.

~num_items~: The number of apples we want to buy.

~solve_k~ return the minimum cost for buying exactly ~num_items~ of
apples.

#+begin_src C
  double min(double v1, double v2) {
      if (v1 <v2)
          return v1;
      else
          return v2;
  }

  double solve_k(int num[], double price[], int num_schemes,
                 double unit_price, int num_items) {
      double best, result;
      int i;
      if (num_items == 0)
          return 0;
      else {
          result = solve_k(num, price, num_schemes, unit_price,
                           num_items -1);
          best = result + unit_price;
          for (i = 0; i < num_schemes; i++)
              if (num_items - num[i] >= 0) {
                  result = solve_k(num, price, num_schemes, unit_price,
                                   num_items - num[i]);
                  best = min(best, result + price[i]);
              }
          return best;
      }
  }
#+end_src

~solve_k~ is analogous to ~solve_t~ in Burger Fervor, with one
difference: the for loop. In Burger Fervor we only had to subproblems
to try. Here, instead, we have a subproblem for each pricing schemes
and a subproblem for the purchase of a single apple. So we need to
loop over the pricing schemes.

This function, however, does not deal with the fact that we might want
to buy more than /k/ apples sometimes. In some cases, the right thing
to do is buying more than /k/ apples because it'll be the cheapest
thing to do in order to buy /at least k/ apples. This problems could
be solved with a ~solve~ function analogous to the one in Burger
Fervor:
#+begin_src C
  double solve(int num[], double price[], int num_schemes,
               double unit_price, int num_items) {
      double best;
      int i;
      best = solve_k(num, price, num_schemes,
                     unit_price, num_items);
      for (i = num_items + 1; i < ???; i++)
          best = min(best, solve_k(num, price, num_schemes,
                                   unit_price, i));
      return best;
  }
#+end_src
We use a for loop to trying larger and larger number of apples. But
how do we know when to stop? The number of apples in a given pricing
schemes is at most 100...

#+begin_src C
  #define SIZE 200

  double solve(int num[], double price[], int num_schemes,
               double unit_price, int num_items) {
      double best;
      int i;
      best = solve_k(num, price, num_schemes,
                     unit_price, num_items);
      for (i = num_items + 1; i < SIZE; i++)
          best = min(best, solve_k(num, price, num_schemes,
                                   unit_price, i));
      return best;
  }
#+end_src

Here is the main function.
#+begin_src C
  #define MAX_SCHEMES 20

  int main(void) {
      int test_case, num_schemes, num_items, more, i;
      double unit_price, result;
      int num[MAX_SCHEMES];
      double price[MAX_SCHEMES];
      test_case = 0;
      while (scanf("%lf%d", &unit_price, &num_schemes) != -1) {
          test_case++;
          for (i = 0; i < num_schemes; i++)
              scanf("%d%lf", &num[i], &price[i]);
          scanf(" ");
          printf("Case %d:\n", test_case);
          more = get_number(&num_items);
          while (more) {
              result = solve(num, price, num_schemes, unit_price,
                             num_items);
              printf("Buy %d for $%.2f\n", num_items, result);
              more = get_number(&num_items);
          }
          result = solve(num, price, num_schemes, unit_price,
                         num_items);
          printf("Buy %d for $%.2f\n", num_items, result);
      }
      return 0;
  }
#+end_src

#+begin_src C
  int get_number(int *num) {
      int ch;
      int ret = 0;
      ch = getchar();
      while (ch != ' ' && ch != '\n') {
          ret = ret * 10 + ch - '0';
          ch = getchar();
      }
      num = ret;
      return ch == ' ';
  }
#+end_src

This works, but it takes ages...

** Memoization
We can declare memo in main:

#+begin_src C
  int main(void) {
      int test_case, num_schemes, num_items, more, i;
      double unit_price, result;
      int num[MAX_SCHEMES];
      double price[MAX_SCHEMES];
      double memo[SIZE];
      test_case = 0;
      while (scanf("%lf%d", &unit_price, &num_schemes) != -1) {
          test_case++;
          for (i = 0; i < num_schemes; i++)
              scanf("%d%lf", &num[i], &price[i]);
          scanf(" ");
          printf("Case %d:\n", test_case);
          for (i = 0; i < SIZE; i++)
	          memo[i] = -1;
          more = get_number(&num_items);
          while (more) {
              result = solve(num, price, num_schemes, unit_price,
                             num_items);
              printf("Buy %d for $%.2f\n", num_items, result);
              more = get_number(&num_items);
          }
          result = solve(num, price, num_schemes, unit_price,
                         num_items);
          printf("Buy %d for $%.2f\n", num_items, result);
      }
      return 0;
  }
#+end_src

We have to change ~solve~ a and ~solve_k~ too.

#+begin_src C
  double solve(int num[], double price[], int num_schemes,
               double unit_price, int num_items, double memo[]) {
      double best;
      int i;
      best = solve_k(num, price, num_schemes, unit_price,
                     num_items, memo);
      for (i = num_items + 1; i < SIZE; i++)
          best = min(best, solve_k(num, price, num_schemes,
                                   unit_price, i, memo));
      return best;
  }
#+end_src

#+begin_src C
  double solve_k(int num[], double price[], int num_schemes,
                 double unit_price, int num_items, double memo[]) {
      double best, result;
      int i;
      if (memo[num_items] != -1)
          return memo[num_items];
      if (num_items == 0) {
          memo[num_items] = 0;
          return memo[num_items];
      } else {
          result = solve_k(num, price, num_schemes, unit_price,
                           num_items - 1, memo);
          best = result + unit_price;
          for (i = 0; i < num_schemes; i++)
              if (num_items - num[i] >= 0) {
                  result = solve_k(num, price, num_schemes, unit_price,
                                   num_items - num[i], memo);
                  best = min(best, result + price[i]);
              }
          memo[num_items] = best;
          return memo[num_items];
      }
  }
#+end_src
This works and it's not slow...

The book stops here with respect to this problem. However a possible
exercise is implementing a dynamic programming solution.


* Hockey Rivalry 
[[./cco18p1_1.png]]
[[./cco18p1_2.png]]
[[./cco18p1_3.png]]

* Recursive Solution
#+begin_src C
  int max(int v1, int v2) {
      if (v1 > v2)
          return v1;
      else
          return v2;
  }

  // i = the number of Geese games that we are considiering in this subproblem
  // j = the number of Hawks games that we are considiering in this subproblem
  int solve(char outcome1[], char outcome2[], int goals1[],
            int goals2[], int i, int j) {
      int first, second, third, fourth;
      if (i == 0 || j == 0)
          return 0;
      if ((outcome1[i] == 'W' && outcome2[j] == 'L' &&
           goals1[i] > goals2[j]) ||
           (outcome1[i] == 'L' && outcome2[j] == 'W' &&
            goals1[i] < goals2[j]))
          first = solve(outcome1, outcome2, goals1, goals2, i - 1, j - 1) +
              goals1[i] + goals2[j];
      else
          first = 0;
      second = solve(outcome1, outcome2, goals1, goals2, i - 1, j - 1);
      third = solve(outcome1, outcome2, goals1, goals2, i - 1, j);
      fourth = solve(outcome1, outcome2, goals1, goals2, i, j - 1);
      return max(first, max(second, max(third, fourth)));
  }
 
  #define SIZE 1000

  int main(void) {
      int i, n, result;
      char outcome1[SIZE + 1], outcome2[SIZE + 1];
      int goals1[SIZE + 1], goals2[SIZE + 1];
      scanf("%d ", &n);
      for (int i = 1; i <= n; i++) {
          scanf("%c", &outcome1[i]);
      }
      for (int i = 1; i <= n; i++) {
          scanf("%d ", &goals1[i]);
      }
      for (int i = 1; i <= n; i++) {
          scanf("%c", &outcome2[i]);
      }
      for (int i = 1; i <= n; i++) {
          scanf("%d ", &goals2[i]);
      }

      result = solve(outcome1, outcome2, goals1, goals2, n, n);
      return 0;
  }
#+end_src

* Memoization
#+begin_src C
  int main(void) {
      int i, n, result;
      char outcome1[SIZE + 1], outcome2[SIZE + 1];
      int goals1[SIZE + 1], goals2[SIZE + 1];
      static int memo[SIZE + 1][SIZE + 1]; // the array is huge so we make it static
      scanf("%d ", &n);
      for (int i = 1; i <= n; i++) {
          scanf("%c", &outcome1[i]);
      }
      for (int i = 1; i <= n; i++) {
          scanf("%d ", &goals1[i]);
      }
      for (int i = 1; i <= n; i++) {
          scanf("%c", &outcome2[i]);
      }
      for (int i = 1; i <= n; i++) {
          scanf("%d ", &goals2[i]);
      }
      for (i = 0; i <= SIZE; i++)
          for (j = 0; j <= SIZE; j++)
              memo[i][j] = -1;
      result = solve(outcome1, outcome2, goals1, goals2, n, n, memo);
      printf("%d\n", result);
      return 0;
  }

  int solve(char outcome1[], char outcome2[], int goals1[],
            int goals2[], int i, int j, int memo[SIZE +1][SIZE +1]) {
      int first, second, third, fourth;
      if (memo[i][j] != -1)
          return memo[i][j];
      if (i == 0 || j == 0) {
          memo[i][j] = 0;
          return memo[i][j];
      }
      if ((outcome1[i] == 'W' && outcome2[j] == 'L' &&
           goals1[i] > goals2[j]) ||
           (outcome1[i] == 'L' && outcome2[j] == 'W' &&
            goals1[i] < goals2[j]))
          first = solve(outcome1, outcome2, goals1, goals2, i - 1, j - 1, memo) +
              goals1[i] + goals2[j];
      else
          first = 0;
      second = solve(outcome1, outcome2, goals1, goals2, i - 1, j - 1, memo);
      third = solve(outcome1, outcome2, goals1, goals2, i - 1, j, memo);
      fourth = solve(outcome1, outcome2, goals1, goals2, i, j - 1, memo);
      memo[i][j] = max(first, max(second, max(third, fourth)));
      return memo[i][j];
  }
#+end_src

* Dynamic Programming
#+begin_src C
  int solve(char outcome1[], char outcome2[], int goals1[],
            int goals2[], int n) {
      int i, j;
      int first, second, third, fourth;
      static int dp[SIZE + 1][SIZE + 1];
      for (i = 0; i <= n; i++)
          dp[0][i] = 0;
      for (i = 0; i <= n; i++)
          dp[i][0] = 0;
      for (i = 1; i <= n; i++)
          for (j = 1; j <= n; j++) {
              if ((outcome[i] == 'W' && outcome2[j] == 'L' &&
                   goals[i] > goals2[j]) ||
                  (outcome[i] == 'L' && outcome2[j] == 'W' &&
                   goals1[i] < goals2[j]))
                  first = dp[i-1][j-1] + goals1[i] + goals2[j];
              else		
                  first = 0;
              second = dp[i-1][j-1];
              third = dp[i-1][j];
              fourth = dp[i][j-1];
              dp[i][j] = max(first, max(second, max(third, fourth)));
          }
      return dp[n][n];
  }

  int main(void) {
      int i, n, result;
      char outcome1[SIZE + 1], outcome2[SIZE + 1];
      int goals1[SIZE + 1], goals2[SIZE + 1];
      static int memo[SIZE + 1][SIZE + 1]; // the array is huge so we make it static
      scanf("%d ", &n);
      for (int i = 1; i <= n; i++) {
          scanf("%c", &outcome1[i]);
      }
      for (int i = 1; i <= n; i++) {
          scanf("%d ", &goals1[i]);
      }
      for (int i = 1; i <= n; i++) {
          scanf("%c", &outcome2[i]);
      }
      for (int i = 1; i <= n; i++) {
          scanf("%d ", &goals2[i]);
      }
      for (i = 0; i <= SIZE; i++)
          for (j = 0; j <= SIZE; j++)
              memo[i][j] = -1;
      result = solve(outcome1, outcome2, goals1, goals2, n);
      printf("%d\n", result);
      return 0;
  }
#+end_src
** Using two one-dimensional arrays instead of one two-dimensional one
#+begin_src C
  int solve(char outcome1[], char outcome2[], int goals1[],
            int goals2[], int n) {
      int i, j, k;
      int first, second, third, fourth;
      static int previous[SIZE +1], current[SIZE +1];
      for (i = 0; i <= n; i++)
          previous[i] = 0;
      for (i = 1; i <= n; i++) {
          for (j = 1; j <= n; j++) {
              if ((outcome[i] == 'W' && outcome2[j] == 'L' &&
                   goals1[i] > goals2[j]) ||
                  (outcome[i] == 'L' && outcome2[j] == 'W' &&
                   goals1[i] < goals2[j]))
                  first = previous[j-1] + goals1[i] + goals2[j];
              else
                  first = 0;
              second = previous[j-1];
              third = previous[j];
              fourth = previous[j-1];
              current[j] = max(first, max(second, max(third, fourth)));		 
          }
          for (k = 0; k < SIZE; k++)
              previous[k] = current[k];
      }
      return current[n];
  }
#+end_src

